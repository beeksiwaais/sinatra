use super::super::super::events::FileEvent;
use std::collections::HashMap;
use std::path::PathBuf;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum BucketAccess {
    PublicRead,
    Authenticated,
}

pub type UploadEventFactory = fn(PathBuf, String, Option<HashMap<String, String>>) -> FileEvent;

#[derive(Debug, Clone, Copy)]
pub struct Bucket {
    pub name: &'static str,
    pub access: BucketAccess,
    pub allow_put: bool,
    pub allow_get: bool,
    pub events_enabled: bool,
    pub upload_event_builder: Option<UploadEventFactory>,
}

fn stream_upload_factory(
    path: PathBuf,
    bucket: String,
    metadata: Option<HashMap<String, String>>,
) -> FileEvent {
    FileEvent::StreamUpload {
        path,
        bucket,
        metadata,
    }
}

fn nle_upload_factory(
    path: PathBuf,
    bucket: String,
    metadata: Option<HashMap<String, String>>,
) -> FileEvent {
    FileEvent::NleUpload {
        path,
        bucket,
        metadata,
    }
}

pub const STREAM: Bucket = Bucket {
    name: "stream",
    access: BucketAccess::Authenticated,
    allow_put: true,
    allow_get: true,
    events_enabled: true,
    upload_event_builder: Some(stream_upload_factory),
};

pub const NLE: Bucket = Bucket {
    name: "nle",
    access: BucketAccess::Authenticated,
    allow_put: true,
    allow_get: true,
    events_enabled: true,
    upload_event_builder: Some(nle_upload_factory),
};

pub const HLS: Bucket = Bucket {
    name: "hls",
    access: BucketAccess::PublicRead,
    allow_put: false, // HLS segments are generated by the system, not PUT by users
    allow_get: true,
    events_enabled: false,
    upload_event_builder: None,
};

pub const ALL_BUCKETS: &[Bucket] = &[STREAM, NLE, HLS];

pub fn find(name: &str) -> Option<&'static Bucket> {
    ALL_BUCKETS.iter().find(|b| b.name == name)
}
